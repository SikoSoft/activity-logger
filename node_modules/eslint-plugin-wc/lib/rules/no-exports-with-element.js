/**
 * @fileoverview Disallows exports alongside custom element exports
 * @author James Garbutt <https://github.com/43081j>
 * @author Keith Cirkel <https://github.com/keithamus>
 */
import { isCustomElement } from '../util.js';
import { resolveReference } from '../util/ast.js';
const classSelector = 'ExportNamedDeclaration :matches(' +
    'ClassDeclaration, ClassExpression, FunctionDeclaration)';
const rule = {
    meta: {
        docs: {
            description: 'Disallows exports alongside custom element exports',
            url: 'https://github.com/43081j/eslint-plugin-wc/blob/master/docs/rules/no-exports-with-element.md'
        },
        messages: {
            noExports: 'No additional exports should be defined when exporting a ' +
                'custom element'
        }
    },
    create(context) {
        const seenClasses = new Set();
        const exportedNodes = new Set();
        let hasElement = false;
        const source = context.sourceCode;
        return {
            'ClassDeclaration,ClassExpression': (node) => {
                if (isCustomElement(context, node, source.getJSDocComment(node))) {
                    hasElement = true;
                    seenClasses.add(node);
                }
                // Allow classes which inherit `Event` since they're likely
                // useful alongside the element
                if (node.superClass &&
                    node.superClass.type === 'Identifier' &&
                    node.superClass.name === 'Event') {
                    seenClasses.add(node);
                }
            },
            'ExportNamedDeclaration > VariableDeclaration > VariableDeclarator': (node) => {
                if (node.init) {
                    exportedNodes.add(node.init);
                }
            },
            'ExportNamedDeclaration ExportSpecifier': (node) => {
                exportedNodes.add(node.local);
            },
            [classSelector]: (node) => {
                exportedNodes.add(node);
            },
            ExportDefaultDeclaration: (node) => {
                let declaration = node.declaration;
                if (declaration.type === 'AssignmentExpression') {
                    declaration = declaration.right;
                }
                exportedNodes.add(declaration);
            },
            'Program:exit': () => {
                if (!hasElement) {
                    return;
                }
                for (const ref of exportedNodes) {
                    const node = resolveReference(ref, context);
                    if (seenClasses.has(node)) {
                        continue;
                    }
                    context.report({
                        node,
                        messageId: 'noExports'
                    });
                }
            }
        };
    }
};
export default rule;
