/**
 * @fileoverview Enforces that the `define(...)` call happens after the
 * associated class has been defined
 * @author James Garbutt <https://github.com/43081j>
 * @author Keith Cirkel <https://github.com/keithamus>
 */
import { isCustomElement } from '../util.js';
import { isDefineCall } from '../util/customElements.js';
import { resolveReference } from '../util/ast.js';
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const rule = {
    meta: {
        docs: {
            description: 'Enforces that the `define(...)` call happens after' +
                ' the associated class has been defined',
            url: 'https://github.com/43081j/eslint-plugin-wc/blob/master/docs/rules/define-tag-after-class-definition.md'
        },
        messages: {
            unregistered: 'Custom element class has not been registered with ' +
                ' a `customElements.define` call',
            noExpressions: 'Custom element classes should not be declared inline. ' +
                'They should be exported as concrete class declarations.'
        }
    },
    create(context) {
        const seenClasses = new Set();
        const source = context.sourceCode;
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        return {
            'ClassDeclaration,ClassExpression': (node) => {
                if (isCustomElement(context, node, source.getJSDocComment(node)) &&
                    node.id?.type === 'Identifier') {
                    seenClasses.add(node);
                }
            },
            CallExpression: (node) => {
                const tagClass = node.arguments[1];
                if (isDefineCall(node)) {
                    if (tagClass.type === 'Identifier') {
                        const resolved = resolveReference(tagClass, context);
                        if (resolved) {
                            seenClasses.delete(resolved);
                        }
                    }
                    else if (tagClass.type === 'ClassExpression') {
                        seenClasses.delete(tagClass);
                        context.report({
                            node: tagClass,
                            messageId: 'noExpressions'
                        });
                    }
                }
            },
            'Program:exit': () => {
                for (const node of seenClasses) {
                    context.report({
                        node,
                        messageId: 'unregistered'
                    });
                }
                seenClasses.clear();
            }
        };
    }
};
export default rule;
