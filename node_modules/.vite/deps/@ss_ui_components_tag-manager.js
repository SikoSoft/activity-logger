import "./chunk-XOSH2YAQ.js";
import "./chunk-2PYGIOL7.js";
import {
  repeat
} from "./chunk-HF2IGRDM.js";
import {
  theme
} from "./chunk-3IYY47KY.js";
import {
  customElement,
  property,
  state
} from "./chunk-UZUV3VNE.js";
import "./chunk-RMSEGTBR.js";
import {
  LitElement
} from "./chunk-M5Y2UPGE.js";
import {
  css
} from "./chunk-SBXOPBOA.js";
import {
  html,
  nothing
} from "./chunk-32RPEPIA.js";

// node_modules/@ss/ui/dist/components/tag-manager/tag-manager.events.js
var tagsUpdatedEventName = "tags-updated";
var TagsUpdatedEvent = class extends CustomEvent {
  constructor(payload) {
    super(tagsUpdatedEventName, {
      bubbles: true,
      composed: true,
      detail: payload
    });
  }
};

// node_modules/@ss/ui/dist/components/tag-manager/tag-input/tag-input.models.js
var TagInputProp;
(function(TagInputProp2) {
  TagInputProp2["VALUE"] = "value";
  TagInputProp2["ENABLE_SUGGESTIONS"] = "enableSuggestions";
})(TagInputProp || (TagInputProp = {}));
var tagInputProps = {
  [TagInputProp.VALUE]: {
    default: "",
    control: "text",
    description: "The input value"
  },
  [TagInputProp.ENABLE_SUGGESTIONS]: {
    default: true,
    control: "boolean",
    description: "Enable tag suggestions"
  }
};

// node_modules/@ss/ui/dist/components/tag-manager/tag-input/tag-input.events.js
var tagInputUpdatedEventName = "tag-input-updated";
var TagInputUpdatedEvent = class extends CustomEvent {
  constructor(payload) {
    super(tagInputUpdatedEventName, {
      bubbles: true,
      composed: true,
      detail: payload
    });
  }
};
var tagAddedEventName = "tag-added";
var TagAddedEvent = class extends CustomEvent {
  constructor(payload) {
    super(tagAddedEventName, {
      bubbles: true,
      composed: true,
      detail: payload
    });
  }
};
var tagSuggestionsRequestedEventName = "tag-suggestions-requested";
var TagSuggestionsRequestedEvent = class extends CustomEvent {
  constructor(payload) {
    super(tagSuggestionsRequestedEventName, {
      bubbles: true,
      composed: true,
      detail: payload
    });
  }
};

// node_modules/@ss/ui/dist/components/tag-manager/tag-input/tag-input.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a;
var _a2;
var TagInput = (_a2 = class extends LitElement {
  constructor() {
    super(...arguments);
    this.suggestionTimeout = null;
    this[_a] = tagInputProps[TagInputProp.VALUE].default;
    this.suggestions = [];
    this.lastInputHadResults = true;
    this.lastInput = "";
  }
  get showButton() {
    return this.value.length > 0;
  }
  async firstUpdated(_changedProperties) {
    var _a7;
    super.firstUpdated(_changedProperties);
    await this.updateComplete;
    const slotNode = (_a7 = this.shadowRoot) == null ? void 0 : _a7.querySelector("slot");
    if (slotNode) {
      slotNode.addEventListener("slotchange", () => {
        this.syncSlotItems();
      });
    }
    this.syncSlotItems();
  }
  syncSlotItems() {
    this.suggestions = [];
    this.querySelectorAll("data-item").forEach((item) => {
      this.suggestions.push(item.textContent || "");
    });
  }
  handleSubmitted() {
    this.save();
  }
  async handleChanged(e) {
    this.value = e.detail.value;
    this.dispatchEvent(new TagInputUpdatedEvent({
      value: this.value
    }));
    if (this.suggestionTimeout) {
      clearTimeout(this.suggestionTimeout);
    }
    this.suggestionTimeout = setTimeout(() => {
      this.requestSuggestions();
    }, 200);
  }
  async requestSuggestions() {
    this.dispatchEvent(new TagSuggestionsRequestedEvent({ value: this.value }));
  }
  handleSaveClick(e) {
    this.save();
  }
  save() {
    this.sendAddedEvent();
    this.value = "";
  }
  sendAddedEvent() {
    this.dispatchEvent(new TagAddedEvent({
      tag: this.value
    }));
  }
  render() {
    return html`
      <div class="tag-input">
        <slot id="data-slot"></slot>

        <ss-input
          @input-submitted=${this.handleSubmitted}
          @input-changed=${this.handleChanged}
          placeholder="Tag"
          value=${this.value}
          .suggestions=${this.suggestions}
          autoComplete
        ></ss-input>

        ${this.showButton ? html`
              <ss-button text="Add" @click=${this.handleSaveClick}></ss-button>
            ` : nothing}
      </div>
    `;
  }
}, _a = TagInputProp.VALUE, _a2.styles = [
  theme,
  css`
      #data-slot {
        display: none;
      }

      .tag-input {
        display: flex;
      }

      ss-input {
        flex-grow: 7;
      }

      ss-button {
        flex-grow: 3;
      }
    `
], _a2);
__decorate([
  property({ type: String, reflect: true })
], TagInput.prototype, _a, void 0);
__decorate([
  state()
], TagInput.prototype, "suggestions", void 0);
__decorate([
  state()
], TagInput.prototype, "lastInputHadResults", void 0);
__decorate([
  state()
], TagInput.prototype, "lastInput", void 0);
TagInput = __decorate([
  customElement("tag-input")
], TagInput);

// node_modules/@ss/ui/dist/components/tag-manager/tag-list/tag-list.models.js
var TagListProp;
(function(TagListProp2) {
  TagListProp2["TAGS"] = "tags";
})(TagListProp || (TagListProp = {}));
var tagListProps = {
  [TagListProp.TAGS]: {
    default: [],
    control: "text",
    description: "The list of tags"
  }
};

// node_modules/@ss/ui/dist/components/tag-manager/tag-list/tag-list.events.js
var tagDeletedEventName = "tag-deleted";
var TagDeletedEvent = class extends CustomEvent {
  constructor(payload) {
    super(tagDeletedEventName, {
      bubbles: true,
      composed: true,
      detail: payload
    });
  }
};

// node_modules/@ss/ui/dist/components/tag-manager/tag-list/tag-list.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a3;
var _a4;
var TagList = (_a4 = class extends LitElement {
  constructor() {
    super(...arguments);
    this[_a3] = tagListProps[TagListProp.TAGS].default;
  }
  connectedCallback() {
    super.connectedCallback();
  }
  deleteTag(tag) {
    this.dispatchEvent(new TagDeletedEvent({ tag }));
  }
  render() {
    return html`
      <ul class="tag-list" part="list">
        ${repeat(this.tags, (tag) => tag, (tag) => html`
            <li part="item">
              ${tag}
              <span
                part="delete"
                class="delete"
                @click=${() => {
      this.deleteTag(tag);
    }}
                >&#215;</span
              >
            </li>
          `)}
      </ul>
    `;
  }
}, _a3 = TagListProp.TAGS, _a4.styles = [
  theme,
  css`
      .tag-list {
        list-style: none;
        margin: 0;
        padding: 0.5rem 0;
        display: flex;
        flex-wrap: wrap;
      }

      .tag-list li {
        display: inline-block;
        padding: 0.25rem;
        border-radius: 0.125rem;
        border: 1px #ccc solid;
        background-color: #efefef;
        position: relative;
      }

      .tag-list li .delete {
        display: inline-block;
        background-color: var(--negative-color);
        border-radius: 0.25rem;
        border: 1px rgba(255, 255, 255, 0.5) outset;
        padding: 0.25rem;
        color: #fff;
        font-size: 1.5rem;
        vertical-align: middle;
        width: 1rem;
        height: 1rem;
        line-height: 1rem;
        cursor: pointer;
      }
    `
], _a4);
__decorate2([
  property({ type: Array })
], TagList.prototype, _a3, void 0);
TagList = __decorate2([
  customElement("tag-list")
], TagList);

// node_modules/@ss/ui/dist/components/tag-manager/tag-manager.models.js
var TagManagerProp;
(function(TagManagerProp2) {
  TagManagerProp2["VALUE"] = "value";
  TagManagerProp2["ENABLE_SUGGESTIONS"] = "enableSuggestions";
})(TagManagerProp || (TagManagerProp = {}));
var tagManagerProps = {
  [TagManagerProp.VALUE]: {
    default: "",
    control: "text",
    description: "The input value"
  },
  [TagManagerProp.ENABLE_SUGGESTIONS]: {
    default: true,
    control: "boolean",
    description: "Enable tag suggestions"
  }
};

// node_modules/@ss/ui/dist/util/msg.js
function msg(key) {
  return key;
}

// node_modules/@ss/ui/dist/components/tag-manager/tag-manager.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a5;
var _b;
var _a6;
var TagManager = (_a6 = class extends LitElement {
  constructor() {
    super(...arguments);
    this[_a5] = tagManagerProps[TagManagerProp.VALUE].default;
    this[_b] = tagManagerProps[TagManagerProp.ENABLE_SUGGESTIONS].default;
    this.tags = [];
    this.suggestions = [];
  }
  connectedCallback() {
    super.connectedCallback();
  }
  setupTagsMutationObserver() {
    var _a7;
    const tagsSlot = (_a7 = this.shadowRoot) == null ? void 0 : _a7.querySelector('slot[name="tags"]');
    if (!tagsSlot) {
      return;
    }
    const slottedElements = tagsSlot.assignedElements();
    const observer = new MutationObserver(() => {
      this.syncSlotTags();
    });
    slottedElements.forEach((element) => {
      observer.observe(element, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    });
  }
  setupSuggestionsMutationObserver() {
    var _a7;
    const suggestionsSlot = (_a7 = this.shadowRoot) == null ? void 0 : _a7.querySelector('slot[name="suggestions"]');
    if (!suggestionsSlot) {
      return;
    }
    const slottedElements = suggestionsSlot.assignedElements();
    const observer = new MutationObserver(() => {
      this.syncSlotSuggestions();
    });
    slottedElements.forEach((element) => {
      observer.observe(element, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      });
    });
  }
  async firstUpdated(_changedProperties) {
    var _a7, _b2;
    super.firstUpdated(_changedProperties);
    await this.updateComplete;
    const tagsSlotNode = (_a7 = this.shadowRoot) == null ? void 0 : _a7.querySelector('slot[name="tags"]');
    if (tagsSlotNode) {
      tagsSlotNode.addEventListener("slotchange", () => {
        this.syncSlotTags();
      });
    }
    this.setupTagsMutationObserver();
    this.setupSuggestionsMutationObserver();
    this.syncSlotTags();
    const suggestionsSlotNode = (_b2 = this.shadowRoot) == null ? void 0 : _b2.querySelector('slot[name="suggestions"]');
    if (suggestionsSlotNode) {
      suggestionsSlotNode.addEventListener("slotchange", () => {
        this.syncSlotSuggestions();
      });
    }
    this.syncSlotSuggestions();
  }
  syncSlotTags() {
    this.tags = [];
    this.querySelectorAll('[slot="tags"] data-item').forEach((item) => {
      this.tags.push(item.textContent || "");
    });
  }
  syncSlotSuggestions() {
    this.suggestions = [];
    this.querySelectorAll('[slot="suggestions"] data-item').forEach((item) => {
      this.suggestions.push(item.textContent || "");
    });
  }
  handleTagAdded(e) {
    this.tags = [...this.tags, e.detail.tag];
    this.sendUpdatedEvent();
  }
  handleDeleted(e) {
    this.tags = this.tags.filter((tag) => tag !== e.detail.tag);
    this.sendUpdatedEvent();
  }
  handleInputUpdated(e) {
    this.value = e.detail.value;
  }
  handleSuggestionsUpdated(e) {
    this.suggestions = e.detail.suggestions;
  }
  sendUpdatedEvent() {
    this.dispatchEvent(new TagsUpdatedEvent({ tags: this.tags }));
  }
  render() {
    return html`
      <fieldset class="tag-manager">
        <legend>${msg("Tags")}</legend>

        <tag-input
          value=${this.value}
          ?enableSuggestions=${this.enableSuggestions}
          @tag-input-updated=${this.handleInputUpdated}
          @tag-added=${this.handleTagAdded}
          @tag-suggestions-updated=${this.handleSuggestionsUpdated}
        >
          ${repeat(this.suggestions, (suggestion) => suggestion, (suggestion) => html` <data-item>${suggestion}</data-item> `)}
        </tag-input>

        ${this.tags.length ? html` <tag-list
              .tags=${this.tags}
              @tag-deleted=${(e) => {
      this.handleDeleted(e);
    }}
            ></tag-list>` : html`<div class="no-tags">${msg("No tags are set")}</div>`}

        <slot name="tags"></slot>

        <slot name="suggestions"></slot>
      </fieldset>
    `;
  }
}, _a5 = TagManagerProp.VALUE, _b = TagManagerProp.ENABLE_SUGGESTIONS, _a6.styles = [
  theme,
  css`
      .tag-manager {
        border-radius: 0.25rem;
        border: 1px #ccc solid;
      }

      .no-tags {
        margin-top: 0.5rem;
        color: #666;
        font-size: 0.75rem;
      }

      slot {
        display: none;
      }
    `
], _a6);
__decorate3([
  property({ type: String, reflect: true })
], TagManager.prototype, _a5, void 0);
__decorate3([
  property({ type: Boolean, reflect: true })
], TagManager.prototype, _b, void 0);
__decorate3([
  state()
], TagManager.prototype, "tags", void 0);
__decorate3([
  state()
], TagManager.prototype, "suggestions", void 0);
TagManager = __decorate3([
  customElement("tag-manager")
], TagManager);
export {
  TagManager
};
//# sourceMappingURL=@ss_ui_components_tag-manager.js.map
